* This might be the way to do the IMU: 
  * Change those quat *'s to quat[4]
  * It'd be nice to init the madgewick algorithm with the very first poll being the starting quat.
    * I think line 367 shouldn't run on the first iteration
    * Maybe on iteration 1 , it doesn't weight the position, but instead - sets it.
  * True north vs mag north?

* Sketch out a home screen that incorporates throttle and servo state
  * signal and battery on the home page would be nice/needed...
  * 3d view with a model? maybe just rotate it via a constant for now

* Get the battery turned on, and maybe even start using the minnow?
  * We need to try running i2cdetect and/or smbus detect
  * Do the soldering on the interfacekit and the minnow!
  * The cpu temps should be a different sensor - not an analog sensor
    * These may belong in a different tab, along with system voltages and the like
    * Let's not do anything here until we boot up the minnowboard

* Replace the Orientation screen with a flightplan view


-- Test run! Checklist:
  * Compass Calibrate
  * Check for spinning Gyro
  * Wait a minute for the filter to stabilize orientation
  * Battery checks
  * Temp checks

* Perhaps we should do this for the 'production' mode, and switch to apache:
  * http://neovintage.blogspot.de/2012/02/precompile-static-html-pages-with-rails.html
  * https://developers.google.com/maps/documentation/staticmaps/#quick_example

* It'd be nice to add a spec to test for segfaults when the devices aren't connected...

* After testing....
  * GPS TODO:
    * Calculate true north, not mag north. Probably we just need to shell to : http://www.ngdc.noaa.gov/geomag/WMM/soft.shtml
  * GUI : On commloss should retry connection

* Down the line on the phidgets gem:
  Maybe....
  * Remove the type_info and replace with extended_attributes and polled_attributes
    basic attributes (these stay in the struct)
    extended_attributes (these are pointed to and are device specific)
    polled_attriubutes these are the running state variables

    It'd be nice if we alloc'd a struct during the poll interval, and passed that
    to a method for storage, this way we could implement our sequencing code down
    the line. However, I don't think this is practical without some fancy locking,
    as we could end up free'ing the struct before it's done in the ruby thread
  * It would then be nice to have a basic_attributes, extended_attributes, and 
    polled_attributes for each class



