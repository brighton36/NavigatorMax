* Clean up the ruby code
  * I might have borked the GPS - test it out, as it wasn't locking in the living room

* Then work through the temp / / humidity charts
  * Then start sending temperatures out
  * The cpu temps should be a different sensor - not an analog sensor

* On the interfacekit, It'd be nice to set some ports as ratiometric, and some as not-ratio
  * While we're in there, let's show a device class and serial on these:
    ERR: PhidgetNative OnError: Channel 6: 1 sample overrun detected.
    ERR: PhidgetNative OnError: Channel 7: 1 sample overrun detected.
    ERR: PhidgetNative OnError: Channel 6: 1 sample overrun detected.
    ERR: PhidgetNative OnError: Channel 7: 1 sample overrun detected.

  * And then switch the device around after a set of sampels
  * This will only support the data_rate method

* Then work on voltage charts

* Fix the gyro in 3d
* Do something nicer on the gps

* Implement the controllers and servos

-- Test run!

* Perhaps we should do this for the 'production' mode, and switch to apache:
  * http://neovintage.blogspot.de/2012/02/precompile-static-html-pages-with-rails.html
  * https://developers.google.com/maps/documentation/staticmaps/#quick_example

* Back to maps:
  * This is what we should do on the maps:
    https://developers.google.com/maps/documentation/staticmaps/#quick_example
  and cache!

* And about that gyroscope....
  * I think that we need to compute a vector from the deltas on a tick, and rotate
    the dcm by the angles of this vector on each axis

* After testing....
  * GPS TODO:
    * Calculate true north, not mag north. Probably we just need to shell to : http://www.ngdc.noaa.gov/geomag/WMM/soft.shtml
  * GUI : On commloss should retry connection

* Down the line on the phidgets gem:
  * Remove the type_info and replace with extended_attributes and polled_attributes
    basic attributes (these stay in the struct)
    extended_attributes (these are pointed to and are device specific)
    polled_attriubutes these are the running state variables

    It'd be nice if we alloc'd a struct during the poll interval, and passed that
    to a method for storage, this way we could implement our sequencing code down
    the line. However, I don't think this is practical without some fancy locking,
    as we could end up free'ing the struct before it's done in the ruby thread
  * It would then be nice to have a basic_attributes, extended_attributes, and 
    polled_attributes for each class



